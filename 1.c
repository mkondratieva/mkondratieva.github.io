#include <stdio.h> 
#include <stdlib.h>
/*
  Пусть даны два массива целых чисел A и В длиной M и N cooтветственно.
Будем говорить, что массив А более устойчив, чем массив В, если наибольшее
количество одинаковых значений в массиве А строго больше, чем наибольшее количество
одинаковых значений в массиве В. Например, массив A={1,3,7,3,4,3} более
устойчив, чем массив B1={4,5,4,5,2} (в А значение 3 повторяется 3 раза, но в B
любые значения встречаются не более 2 раз).
Определить какой из данных массивов более устойчив.

Ответом является число 1, если А более устойчив, чем B, число -1, если
B более устойчив, чем А, и число 0 в противном случае.
Это число надо вывести в файл output.txt.

Массивы A и B заданы в файлах ina.txt и inb.txt соответственно. 
В файлах записаны только элементы массивов, длины массивов в файлах не указаны. 
При вводе программа должна предварительно подсчитать количество чисел M и N
в файлах и создавать массивы A и B с полученными фактическими длинами M и N.
Использование других рабочих массивов при обработке данных не разрешается. 
Сами исходные массивы A и B могут быть изменены программой в процессе работы.

Результат решения задачи надо вывести в указанной форме в файл output.txt.

Ввод массивов и их обработка для решения поставленной задачи должны 
выполняться в разных функциях (допускается ввод массива в функции main). 
Реализация всех действий внутри одной единственной 
функции не допускается.

При успешном завершении работы функция main должна возвращать значение 0.
Если при выполнении программы возникают критические отказы (при открытии файлов), 
либо данные в файлах оказываются некорректными (из файла не удается прочитать ни одного числа),
то вычисления не производятся и функция main должна возвращать значение -1.
*/
int size(FILE *);// определяет размер массива
void get_massiv(FILE *, int []);// заполняет массив числами из файла 
int fixity(int [], int);// поиск максимального количества одинаковых элементов массива
void print(int [], int);// печать массива
void sort(int [], int);// сортировка

int main(void) 
{ 
    	FILE  *ina=fopen("ina.txt", "r"), 
              *inb=fopen("inb.txt", "r"), //откраываем оба файла с данными
              *out;

    	int na=size(ina),
              nb=size(inb),fa,fb;// находим размеры массивов

    	int a[na],b[nb];   //память выделяется статическая (если в условии не сказано явно, какой способ требуется)
        //printf("%d %d\n",na,nb);    // разумно проконтролировать размеры массивов

        if (ina==0 || inb==0) // если какой-то из файлов не открылся
        {
            if (ina)
                  {
                       fclose(ina); // если в то же время открылся первый, его закрываем
                  }
            if (inb)
                  {
                       fclose(inb); // аналогично  со вторым
                  }
            return -1; // ошибку отрытия файлов обработали
        }

        fclose(ina);   // закрываем файлы, чтобы заполнить массивы 
        fclose(inb);   // альтернативный способ -- вызов функции rewind(ina);...(возврат к началу файла) 
                       

        if(na==0 || nb==0) // если один из входных файлов пуст, файл output.txt не создаем и возвращаем -1
        {
            return -1;
        }

        ina=fopen("ina.txt", "r");//повторно открываем входные файлы и выходной файл
        inb=fopen("inb.txt", "r");
        out=fopen("output.txt", "w");

        get_massiv(ina,a); //заполняем массивы, при этом размер массива можно не передавать
        get_massiv(inb,b);

        //print(a,na);      //здесь разумно оттестировать
        //print(b,nb); 
        //return 0;

        fa=fixity(a,na); // вычисляем нужную характеристику массива
        fb=fixity(b,nb);
	//print(a,na); 
	//print(b,nb); 
        //printf("\n%d %d\n",fa,fb);
               
        if (fa>fb)
        {
            fprintf(out,"1"); // записываем ответ в файл
        }
	if (fa<fb)
        {
            fprintf(out,"-1");
        }
	if (fa==fb)
        {
            fprintf(out,"0");
        }
        fclose(ina); 
        fclose(inb);
        fclose(out); 
        return 0;
}
int size(FILE *in)
{
        int n=0, cur;
        if (in==0)  // чтобы в случае отсутствия файла сразу вернультя в main
        {
            return 0;
        }
        while(fscanf(in,"%d",&cur)==1)
        {
            n++;
        }
        return n;
} 

void print(int a[], int n)
{
        int i; 
        for(i=0;i<n;i++)
        {
            printf("%d ",a[i]);
        }
        printf("\n");
} 

void get_massiv (FILE*in, int a[]) 
{       
        int cur,i=0; 
        while (fscanf(in, "%d", &cur)==1)
        { 
            a[i]=cur;//кладем элемент в свободную ячейку массива и увеличиваем счетчик
            i++;
        }
        
}

void sort(int a[], int n)//этот метод надо изменить на любой  хорошо
{                        //усвоенный нерекурсивный 
        if(n==1)
        {
            return;
        }
        for(int i=1;i<n;i++)
            if(a[i-1]>a[i])
            {
                int u=a[i-1];
                a[i-1]=a[i];
                a[i]=u;
            }

        sort(a,n-1);
}


int fixity(int a[], int n)
{
        int max_f=1, k_f=1;
        sort(a,n);         // для отсортированного массива задача решается легче
        for(int i=1;i<n;i++)
        {
            k_f++;
            if(a[i-1]!=a[i])  // если соседние элементы не равны, закончился постоянный участок 
                 k_f=1;       // длина текущего участка сбрасывется

            if (k_f>max_f) //если текущая длина больше максимальной, максимальную надо изменить
                max_f=k_f;
            
        }
        return max_f;
}
