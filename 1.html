<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>1kurs</title>
  </head>
<center><h1>Работа на ЭВМ, 1  курс, механики, 2019-2020г.</h1></center>
  <body>
<center><a href="2019spisok.pdf">Распределение задач + ход выполнения</a>
Для получения зачета необходимо: сдать тест (первая попытка -- 20.12)
и набрать 10 баллов в течении семестра. Если набрано менее 10, нужно на зачете сделать:
1 новую задачу, если набрано 9 баллов, 2 -- если 8 и 3 -- если менее 8.
Расписание зачетов: 23.12 – 13.00 – 13-16, 24.12 – 10.00 – 13-16,
26.12 – 13.00 – 13-08.

</center>
<p style="color:#ff0000"> Внимание!
Замечания по итогам пробного тестирования.
</p>
<p>                                                                
На зачете будет другой тест, аналогичный по сложности.
Обязательно будут сортировки.
Основные ошибки.
1. Условие не дочитыают до конца.  Это задача не на массивы и не 
последовательности. Она на то и другое вместе.
Например, загружают все элементы файла в массив. Этого нельзя 
делать! Последовательность может быть длиннее  N.
Запоминать в буферном массиве можно только часть последовательности 
(N ее элементов).
Не используем realloc, память выделяем  как malloc (1 раз на число элементов, равное первому числу из файла).
Все это есть в примерах ниже.
2. Отбор элементов из предъокрестности (=буферного массива) 
делается за 2 цикла. Самое простое -- границы этих циклов 
выставить от 0 до количества элементов в буферном массиве. Это количечтво 
принимает значения 1,2...N
(когда буферный массив заполняется, это число не меняется, а при переходе 
 к следующему элементу последоательности 
только обновляется массив). Обновление надо делать независимо от 
того, нашелся элемет с нужным свойством или нет.
3.По условию числа в последовательности неотрицательные, поэтому если по условию надо искать частное, перед делением надо 
проверить, что там не нуль. Более того, оказывается, что деление не нацело, 
как можно было подумать, а это обычное деление (как вещественных чисел). Поэтому вместо деления используем умножение!
4. В условии a=b(mod c) имеется в виду, что a==b%c (остаток от деления).
 
Условия, аналогичные тестовым,  можно посмотреть 
<a href=https://github.com/mkondratieva/1kurs/blob/master/test.txt>
в этом документе </a>. Разбор некоторых задач: 
<a href=https://github.com/mkondratieva/1kurs/blob/master/0.c>
0 </a>, <a href=https://github.com/mkondratieva/1kurs/blob/master/1.c>
1 </a>, <a href=https://github.com/mkondratieva/1kurs/blob/master/2.c>
2 </a>, 
<a href=https://github.com/mkondratieva/1kurs/blob/master/4.c>
4 </a>.   
Вопросы по поводу формулировок и реализаций присылайте на почту.
19.12 жду всех, кто имеет долги по семестровым задачам. 
Остальные по желанию могут еще раз написать тест (его результаты никак не будут учитываться). 

<p>
Тема 1, последовательности. 
<a href="task_1_2019.pdf">Список задач.</a>
</p>
<p>
В программе должна присутствовать функция, вычисляющая нужную характеристику последовательности 
чисел из файла. В ней не должно быть печати. Ошибки (пустой, плохой файл) должны быть обработаны.

В командную строку можно попасть, открыв в домашнем каталоге папку, 
в которой находится файл с программой 
(в примере это 1.c), в меню, которое появится после нажатия 
правой кнопки мыши,
выбрать "действие"-> "открыть терминал в этой папке".
Компилируем программу из командной строки!

<a href="example1.pdf">Пример 1.</a>

Нельзя использовать внешние переменные (это касается  и темы 1, и темы 2).
Объявления переменных должны стоять в начале блока. 
Если при объявлении переменные не инициализированы, в них содержится мусор. Функция может возвращать только одно значение. Для того, чтобы функция изменила значение своего аргумента, его нужно сделать указателем.

<a href="example2.pdf">Пример 2.</a> использует указатели.

Начиная с четвертой задачи, программу нужно компилировать раздельно, см. пример:
<a href="example3.pdf">Пример 3.</a>
 
Из списка 1 нужно сделать 5 задач. Пример программы на поиск фрагмента можно посмотреть 
<a href="fragment.pdf">здесь.</a>

<p>
Список заданий контрольной работы  можно посмотреть 
<a href="k.r.1-2019.pdf">здесь</a>.   Решения этих задач можно найти
<a href=https://github.com/mkondratieva/1kr>в этой папке</a>.
</p>

<p>

Тема 2, массивы. 
<a href="task_2_2019.pdf">Список задач.</a>
</p>
В программе должна присутствовать функция, заполняющая массив 
числами из файла и функция, вычисляющая требуемую характеристику массива (или преобразующая массив).
В этих  функциях  не  должно быть печати. Ошибки (пустой, плохой файл) обработать.
Примеры можно найти 
<a href=https://github.com/mkondratieva/mass>в этой папке</a>.
В частности, в файле massinv_din.c описана функция, динамически 
выделяющая память под массив необходимого размера.

<p>
Набросок задачи на матрицу,
<a href=https://github.com/mkondratieva/mass/blob/master/mass_matrix.c> 
циклически
сдвигающий строки </a>. Здесь используются перевороты отдельных 
участков массива,
<a href=https://github.com/mkondratieva/1kurs/blob/master/invert.pdf> 
эта идея </a> может быть использована во многих задачах.
</p>
<p>
Еще один интересный прием -- рекурсия. Иногда полезно написать программу
с ее использованием, чтобы потом заменить рекурсивные вызовы циклом,
<a href=https://github.com/mkondratieva/1kurs/blob/master/recurs.pdf> 
см. иллюстрацию </a>.

<a href=https://github.com/mkondratieva/mass/blob/master/mass_recurs.c> 
А это реализация </a>.
</p>

<p>
Для просмотра двух вариантов 
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_cycle.py>
циклического сдвига </a> массива требуется 
наличие интерпретатора Python3. Можно его установить у себя уже сейчас, 
т.к.  во 2 семестре это станет необходимостью.
</p>
<p>
Последняя задача темы 2 -- сортировка массива.
<text style="color:#ff0000"> 
Для сортировки заполняем массив случайными числами,
</text> 
 а не берем из 
файла (тестировать на массивах большого размера порядка 10^6)
<a href= https://github.com/mkondratieva/mass/blob/master/sort.c>
пример с qsort</a>.

Сортировка пузырьком заключается в сравнении 
соседних элементов и их обмене, если они стоят в неправильном порядке.  
Один  проход  пузырька максимальный элемент сдвигает в конец массива,  
далее уменьшаем размер массива на 1 и делаем рекурсию. 
Сортировка выбором максимального ищет максимальный элемент и 
обменивает его с последним, далее аналогично (рекурсия).
Пример работы этих алгоритмов в 
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_sort.py>
файле </a>(тоже Питон).
</p> 
<p> 
Метод вставок (простых и бинарных) заключается в 
сортировке начала массива (начинаем с пустого) и 
добавлении к нему очередного элемента путем поиска 
индексов, между которыми этот элемент можно вставить, не нарушая упорядоченности.
Затем  циклически передвигаем нужную часть массива на 1 позицию вправо и повторяем до тех пор, полка
не вставим все элементы.  Демонстрация работы
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_sort_ins.py>
файле </a>. 
Идея 
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_megre.py>
слияния </a> двух упорядоченных массивов в третий заключается в использовании двух индексов (один прсматривает первый массив, другой второй). 
Шаг алгоритма заключается в сравнении выделенных элементов, 
записи меньшего из них в результирующий массив и 
сдвигу по тому ммассиву, в котором лежал минимальный.
</p>
<p>                                                                
Для реализации (одного из вариантов) метода подсчетом нужен 
дополнительный массив  размера n, где n=(k2-k1+1) -- размер диапазона значений (k1,k2) целочисленного массива.
В ячейку с номером k этого массива положим количество элементов массива, равных k1+k. Затем, просматривая этот дополнительный массив, 
можно заполнить исходный отсортированными значениями.
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_sort_count.py> см. слайд </a>.   
</p>
<p>
Поиск порядковой статистики -- рекурсивный вызов сепарирования массива
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_mediana.py>
пример работы </a>.   
</p>
<p>
Для нахождения обратной перестановки и вычисления четности используется разложение перестановки в произведение независимых циклов,
<a href=https://github.com/mkondratieva/1kurs/blob/master/perest.py>
реализация на Питоне </a>.   
</p>
<p>
ля подготовки к автоматизированному зачету  
можно   посмотреть эти примеры:
<a href=https://github.com/mkondratieva/mass/blob/master/1.c> 1 </a>
и 
<a href=https://github.com/mkondratieva/mass/blob/master/2.c> 2 </a>.
Необходимо уметь сортировать массив (любым методом).  
</p>


</body>
</html> 