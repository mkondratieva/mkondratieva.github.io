<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>1kurs</title>
  </head>
<center><h1>Работа на ЭВМ, 1  курс, механики, 2019-2020г.</h1></center>
  <body>
<center><a href="2019spisok.pdf">Распределение задач + ход выполнения</a>
</center>
<p>
Тема 1, последовательности. 
<a href="task_1_2019.pdf">Список задач.</a>
</p>
<p>
В программе должна присутствовать функция, вычисляющая нужную характеристику последовательности 
чисел из файла. В ней не должно быть печати. Ошибки (пустой, плохой файл) должны быть обработаны.

В командную строку можно попасть, открыв в домашнем каталоге папку, 
в которой находится файл с программой 
(в примере это 1.c), в меню, которое появится после нажатия 
правой кнопки мыши,
выбрать "действие"-> "открыть терминал в этой папке".
Компилируем программу из командной строки!

<a href="example1.pdf">Пример 1.</a>

Нельзя использовать внешние переменные (это касается  и темы 1, и темы 2).
Объявления переменных должны стоять в начале блока. 
Если при объявлении переменные не инициализированы, в них содержится мусор. Функция может возвращать только одно значение. Для того, чтобы функция изменила значение своего аргумента, его нужно сделать указателем.

<a href="example2.pdf">Пример 2.</a> использует указатели.

Начиная с четвертой задачи, программу нужно компилировать раздельно, см. пример:
<a href="example3.pdf">Пример 3.</a>
 
Из списка 1 нужно сделать 5 задач. Пример программы на поиск фрагмента можно посмотреть 
<a href="fragment.pdf">здесь.</a>

<p>
Список заданий контрольной работы  можно посмотреть 
<a href="k.r.1-2019.pdf">здесь</a>.   Решения этих задач можно найти
<a href=https://github.com/mkondratieva/1kr>в этой папке</a>.
</p>

<p>

Тема 2, массивы. 
<a href="task_2_2019.pdf">Список задач.</a>
</p>
В программе должна присутствовать функция, заполняющая массив 
числами из файла и функция, вычисляющая требуемую характеристику массива (или преобразующая массив).
В этих  функциях  не  должно быть печати. Ошибки (пустой, плохой файл) обработать.
Примеры можно найти 
<a href=https://github.com/mkondratieva/mass>в этой папке</a>.
В частности, в файле massinv_din.c описана функция, динамически 
выделяющая память под массив необходимого размера.

<p>
Набросок задачи на матрицу,
<a href=https://github.com/mkondratieva/mass/blob/master/mass_matrix.c> 
циклически
сдвигающий строки </a>. Здесь используются перевороты отдельных 
участков массива,
<a href=https://github.com/mkondratieva/1kurs/blob/master/invert.pdf> 
эта идея </a> может быть использована во многих задачах.
</p>
<p>
Еще один интересный прием -- рекурсия. Иногда полезно написать программу
с ее использованием, чтобы потом заменить рекурсивные вызовы циклом,
<a href=https://github.com/mkondratieva/1kurs/blob/master/recurs.pdf> 
см. иллюстрацию </a>.

<a href=https://github.com/mkondratieva/mass/blob/master/mass_recurs.c> 
А это реализация </a>.
</p>

<p>
Для просмотра двух вариантов 
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_cycle.py>
циклического сдвига </a> массива требуется 
наличие интерпретатора Python3. Можно его установить у себя уже сейчас, 
т.к.  во 2 семестре это станет необходимостью.
</p>
<p>
Последняя задача темы 2 -- сортировка массива.
<text style="color:#ff0000"> 
Для сортировки заполняем массив случайными числами,</text>

 а не берем из 
файла (тестировать на массивах большого размера порядка 10^6)
<a href= https://github.com/mkondratieva/mass/blob/master/sort.c>
пример с qsort</a>.

Сортировка пузырьком заключается в сравнении 
соседних элементов и их обмене, если они стоят в неправильном порядке.  
Один  проход  пузырька максимальный элемент сдвигает в конец массива,  
далее уменьшаем размер массива на 1 и делаем рекурсию. 
Сортировка выбором максимального ищет максимальный элемент и 
обменивает его с последним, далее аналогично (рекурсия).
Пример работы этих алгоритмов в 
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_sort.py>
файле </a>(тоже Питон).
<p> 
Метод вставок (простых и бинарных) заключается в 
сортировке начала массива (начинаем с пустого) и 
добавлении к нему очередного элемента путем поиска 
индексов, между которыми этот элемент можно вставить, не нарушая упорядоченности.
Затем  циклически передвигаем нужную часть массива на 1 позицию вправо и повторяем до тех пор, полка
не вставим все элементы.  Демонстрация работы
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_sort_ins.py>
файле </a>. 
</p>
<p>                                                                
Для реализации (одного из вариантов) метода подсчетом нужен 
дополнительный массив  размера n, где n=(k2-k1+1) -- размер диапазона значений (k1,k2) целочисленного массива.
В ячейку k этого массива положим количество элементов массива, равных k1+k. Затем, просматривая этот дополнительный мвссив, 
можно заполнить исходный отсортированными значениями.
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_sort_count.py> см. слайд </a>.   
</p>
<p>
Поиск порядковой статистики -- рекурсивный вызов сепарирования массива
<a href=https://github.com/mkondratieva/1kurs/blob/master/mass_mediana.py>
пример работы </a>.   
</p>


</p>



</body>
</html>